//1000以下の素数を列挙せよ。
//以下、PrimeNumber1からの改良アルゴリズム。
//1000以下の数nに対して、2からn-1までの「素数」で割れるかを確認することで
//PrimeNumber1と比較して計算量を削減する。
//⇒ その時点で求められた素数を配列(prime)に蓄積しておき、蓄えられた素数で除算する。
class PrimeNumber2 {
    int prime[] = new int[500];//その時点での素数を蓄積する配列
    int idx;//とそのインデックス番号
    
    prime[idx++] = 2;//2は素数であることは自明。初めから蓄積しておく。以下for文は3から始める。
    
    for(int n = 3; n <= 1000; n += 2) {//偶数は合成数なので調べない。2個とばしのループ。
        int i;
        for(i = 1; i < idx; i++) {//すでに得られた素数で割る。0からではなく1から(偶数は飛ばしている)
            if(n % prime[i] == 0) {//割り切れたらそこで終了
                break;
            }
        }
        if(idx == i) {//内側のfor文はi=1から始めているため、ループが最後まで実行されると、idx == i となる。
            prime[idx++] = n;
        }
    }
    //求めた素数を出力
    for(int i = 0; i < idx; i++) {
        System.out.println(prime[i]);
    }
    
}